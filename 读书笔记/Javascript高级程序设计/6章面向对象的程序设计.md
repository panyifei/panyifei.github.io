---
layout: default
title: {{ site.name }}
---
# 6章面向对象的程序设计
重新看一次这一章..

对象就是无序属性的集合，属性包含基本值，对象和函数

## 创建简单对象
我们可以new Object()或者通过对象自变量{}的形式来创建。

每个属性都有一些特性，包括

 - Configurable:能够通过delete删除或者重新定义属性的特性
 - Enumerable:能否通过for in循环返回属性
 - Writable:是否可以修改属性的值
 - Value：属性的数据值

一般这些特性都是true的，想要修改的话，我们只能使用`Object.defineProperty`来进行修改。

有种叫做访问器属性，只能通过defineProperty来进行定义，我们可以定义get和set方法，当然可以不全部指定。

我们还可以通过defineProperties来一次定义多个属性。

### 读取属性的特性
Object.getOwnPropertyDescriptor可以得到想要的属性的特性。

## 创建特定形式的对象
### 工厂模式
最初是工厂模式的，就是简单的一个方法，每次new Object()，然后添加属性，最后返回这个新的对象回去，但是问题来了，我们得不到创建出来的东西的类型，于是有了构造函数的模式

### 构造函数
我们使用构造函数来创建对象，每个对象都能访问到contructor(构造函数)属性，该属性指向构造函数(注意这个constructor并不是实例本身拥有的，而是原型对象会有这个constructor，然后属性查找找到了原型上的contructor而已！！！！！)。

只要创建了一个新函数，就会为该函数创建一个prototype，指向该函数的原型对象。

原型对象会有一个constructor，指向构造函数。

实例对象只拥有一个指针能指向原型对象，一般叫做__proto__，基本都是被隐藏的属性！！如果我们想要遍历原型链的话，可以通过ES6的Object.getPrototypeOf来拿，最后一层为null。

所以

 - 只有原型对象才会有contructor！！其他的实例对象能够访问是因为查找了原型！！
 - 只有函数才有prototype！！！实例对象也拥有指针指向原型对象，就是__proto__！！！

我们一旦在实例上申明了属性覆盖了原型属性，除非我们使用`delete`，才能够访问到原型属性。

Object.getOwnPropertyDescriptor只能得到自己对象上属性的描述符，想得到原型对象上的，只能直接在原型对象上调用这个方法。

想要判断属性是不是原型属性：`!Object.hasOwnProperty(name) && (name in object)`

注意constructr和__proto__规范上也是enumerable为false的，当时并不是所有的浏览器都是这么实现的

Object.keys可以得到for in循环的所有属性，当然不包括enumerable为false的;而Object.getOwnPropertyNames()可以得到所有的实例属性，包括不可枚举的，但是__proto__这种不开放的还是得不到。

高程145页是有问题的，他说实例是有constructor的，其实没有..

### 重写原型
一般情况下我们为原型赋予新的属性，得一次次的敲，也可以直接重新给原型对象赋一个新对象

但是问题是我们新建的对象没有constructor了，我们可以在对象里面手动设置为原构造函数。但是直接设置的话，enumerable就是true了，所以我们可以用`Object.defineProperty`来创建。

我们哪怕在生成了之后再进行原型对象的属性赋予，也是可以的。毕竟就是一个指针嘛，但是如果重设成一个对象，那么原来的原型还是老的。新的原型就是新设置的。

注意原型对象的this也被绑定到了新对象！！就是输如果原型方法return this，返回的是自身！！

### 原型模式的弊端
原型模式最大的弊端是在共享属性，如果属性是一个函数的话，还不会有什么问题，如果属性不是函数的话，可能会造成相互影响的问题，除非每次new的时候都比较小心一点。

所以基本上构造函数肯定是和原型模式一起使用的。

这里有个什么动态的原型模式，很无聊，就是在构造函数内部进行判断，然后初始化原型...

还有个什么寄生构造函数模式，乱七八糟的，就是用return一个新的对象来替代new出来的新对象，没啥价值...
